"""
This script analyze the simulations generated by mc_get_kspace_tf_spectra.py
it computes the kspace filter transfer matrix and if we have access to a large number of simulations, a
correction for TE taking into account that tf_TE is not exactly sqrt(tf_TT * tf_EE)
"""
import matplotlib
matplotlib.use("Agg")
from pspy import pspy_utils, so_dict, so_spectra, so_mcm
from pspipe_utils import pspipe_list, best_fits, kspace, log
import numpy as np
import pylab as plt
import sys


d = so_dict.so_dict()
d.read_from_file(sys.argv[1])
log = log.get_logger(**d)

type = d["type"]
surveys = d["surveys"]
iStart = d["iStart"]
iStop = d["iStop"]
lmax = d["lmax"]
n_min_sims = 500


mcm_dir = "mcms"
spec_dir = "sim_spectra_for_tf"
tf_dir = "kspace_tf"
bestfit_dir = "best_fits"
plot_dir = "plots/kspace_tf"

pspy_utils.create_directory(tf_dir)
pspy_utils.create_directory(plot_dir)

clfile = f"{bestfit_dir}/cmb.dat"
spectra = ["TT", "TE", "TB", "ET", "BT", "EE", "EB", "BE", "BB"]
spin_pairs = ["spin0xspin0", "spin0xspin2", "spin2xspin0", "spin2xspin2"]
n_sims = iStop - iStart + 1
scenarios = ["standard", "noE", "noB"]

spec_list = pspipe_list.get_spec_name_list(d, delimiter="_")

_, sv_list, ar_list = pspipe_list.get_arrays_list(d)
array_list = [f"{sv}_{ar}" for (sv, ar) in zip(sv_list, ar_list)]
lth, cmb_and_fg_dict = best_fits.fg_dict_from_files(bestfit_dir + "/fg_{}x{}.dat",
                                                    array_list,
                                                    lmax + 2,
                                                    spectra,
                                                    f_name_cmb=bestfit_dir + "/cmb.dat")


ps_list = {}
for sid, spec in enumerate(spec_list):
    log.info(f"Read all {spec} sim power spectra")

    ps_list[spec] = {}
    for scenario in scenarios:
        for iii in range(iStart, iStop + 1):

            if iii == 0:
                ps_list[spec]["nofilter", scenario] = []
                ps_list[spec]["filter", scenario] = []

            lb, ps_nofilt = so_spectra.read_ps(spec_dir + f"/{type}_{spec}_nofilter_{scenario}_{iii:05d}.dat", spectra=spectra)
            lb, ps_filt = so_spectra.read_ps(spec_dir + f"/{type}_{spec}_filter_{scenario}_{iii:05d}.dat", spectra=spectra)

            ps_list[spec]["nofilter", scenario] += [ps_nofilt]
            ps_list[spec]["filter", scenario] += [ps_filt]


elements  = ["TT_to_TT", "EE_to_EE", "BB_to_BB", "EE_to_BB", "BB_to_EE"]
kspace_matrix = {}

plt.figure(figsize=(12,8))
for spec in spec_list:
    log.info(f"build kspace filter matrix for {spec}")

    kspace_dict, std, kspace_matrix[spec] = kspace.build_kspace_filter_matrix(lb,
                                                                              ps_list[spec],
                                                                              n_sims,
                                                                              spectra,
                                                                              return_dict=True)

    np.save(f"{tf_dir}/kspace_matrix_{spec}.npy", kspace_matrix[spec])
    for count, el in enumerate(elements):
        plt.subplot(3, 2, count+1)
        plt.ylabel(el)
        plt.xlabel(r"$\ell$")
        plt.errorbar(lb, kspace_dict[el], std[el] / np.sqrt(n_sims), label = spec)
plt.legend()
plt.savefig(f"{plot_dir}/kspace_mat.png", bbox_inches="tight")
plt.clf()
plt.close()

# lets also make sure that the corrected spectrum is unbiased


for spec in spec_list:
    log.info(f"plot uncorrected vs corrected mean for {spec} ")


    prefix= f"{mcm_dir}/{spec}"

    mbb_inv, Bbl = so_mcm.read_coupling(prefix=prefix,spin_pairs=spin_pairs)

    n1, n2 = spec.split("x")
    bin_theory = so_mcm.apply_Bbl(Bbl, cmb_and_fg_dict[n1, n2], spectra=spectra)



    for iii in range(iStart, iStop + 1):
        lb, ps_list[spec]["filter", "standard"][iii] = kspace.deconvolve_kspace_filter_matrix(lb,
                                                                                              ps_list[spec]["filter", "standard"][iii],
                                                                                              kspace_matrix[spec],
                                                                                              spectra)

    
    for spectrum in spectra:
        mean, std = {}, {}
        for filt in ["filter", "nofilter"]:

            my_list = []
            for iii in range(iStart, iStop + 1):
                my_list += [ps_list[spec][filt, "standard"][iii][spectrum]]

            mean[filt] = np.mean(my_list, axis=0)
            std[filt] = np.std(my_list, axis=0)

        plt.figure(figsize=(12,8))
        if spectrum == "TT":
            plt.semilogy()

        plt.plot(lth, cmb_and_fg_dict[n1, n2][spectrum], color="grey", alpha=0.4)
        plt.plot(lb, bin_theory[spectrum])
        plt.errorbar(lb, mean["nofilter"], std["nofilter"], fmt=".", color="red", label = "no filter")
        plt.errorbar(lb, mean["filter"], std["filter"], fmt=".", color="blue", label = "filter corrected")

        plt.title(r"$D_{\ell}$", fontsize=20)
        plt.xlabel(r"$\ell$", fontsize=20)
        plt.legend()
        plt.savefig(f"{plot_dir}/{spec}_{spectrum}.png", bbox_inches="tight")
        plt.clf()
        plt.close()

        plt.figure(figsize=(12,8))
        plt.plot(lb, lb * 0)
        plt.errorbar(lb - 10, mean["nofilter"] - bin_theory[spectrum], std["nofilter"]  / np.sqrt(n_sims), fmt=".", color="red", label = "no filter")
        plt.errorbar(lb + 10, mean["filter"] - bin_theory[spectrum], std["filter"]  / np.sqrt(n_sims), fmt=".", color="blue", label = "filter corrected")
        plt.title(r"$\Delta D_{\ell}$" , fontsize=20)
        plt.xlabel(r"$\ell$", fontsize=20)
        plt.legend()
        plt.savefig(f"{plot_dir}/diff_{spec}_{spectrum}.png", bbox_inches="tight")
        plt.clf()
        plt.close()


    if  n_sims > n_min_sims:
        log.info(f"compute xtra correction for TE")

        # xtra_correcton for TE/ET
        # not that we only compute this if we have access to a large number of sim (500)
        # otherwise the error on the correction will be larger than the correction itself

        my_list_TE = []
        my_list_ET = []

        for iii in range(iStart, iStop + 1):
            my_list_TE += [ps_list[spec]["filter", "standard"][iii]["TE"] - ps_list[spec]["nofilter", "standard"][iii]["TE"]]
            my_list_ET += [ps_list[spec]["filter", "standard"][iii]["ET"] - ps_list[spec]["nofilter", "standard"][iii]["ET"]]

        correction_TE = np.mean(my_list_TE, axis=0)
        correction_ET = np.mean(my_list_ET, axis=0)
        sigma_TE = np.std(my_list_TE, axis=0)
        sigma_ET = np.std(my_list_ET, axis=0)

        plt.figure(figsize=(12,8))
        plt.plot(lb, bin_theory["TE"] * 1 / 100, color="black", label= "1% TE")
        plt.errorbar(lb, correction_TE, sigma_TE / np.sqrt(n_sims), fmt="-", label = f"corr TE {spec}")
        plt.errorbar(lb, correction_ET, sigma_ET / np.sqrt(n_sims), fmt="--", label = f"corr ET {spec}")
        plt.legend()
        plt.show()
        plt.savefig(f"{plot_dir}/TE_correction_{spec}.png", bbox_inches="tight")
        plt.clf()
        plt.close()

        # write correction to file
        corr_dict = {}
        for spectrum in spectra:
            corr_dict[spectrum] = lb * 0
        corr_dict["TE"] = correction_TE
        corr_dict["ET"] = correction_ET
        
        so_spectra.write_ps(f"{tf_dir}/TE_correction_{spec}.dat",
                            lb,
                            corr_dict,
                            type=type,
                            spectra=spectra)
