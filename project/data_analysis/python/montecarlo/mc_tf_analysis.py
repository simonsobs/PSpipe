"""
This script analyze the simulations generated by mc_get_spectra.py
it estimates the mean and numerical covariances from the simulations
"""


from pspy import pspy_utils, so_dict, so_spectra, so_mcm
from pspipe_utils import pspipe_list, best_fits, kspace
import numpy as np
import pylab as plt
import sys

d = so_dict.so_dict()
d.read_from_file(sys.argv[1])

type = d["type"]
surveys = d["surveys"]
iStart = d["iStart"]
iStop = d["iStop"]
lmax = d["lmax"]

mcm_dir = "mcms"
spec_dir = "sim_spectra_for_tf"
tf_dir = "transfer_functions"
bestfit_dir = "best_fits"
plot_dir = "plots/transfer_functions"

pspy_utils.create_directory(tf_dir)
pspy_utils.create_directory(plot_dir)

clfile = f"{bestfit_dir}/cmb.dat"
spectra = ["TT", "TE", "TB", "ET", "BT", "EE", "EB", "BE", "BB"]
spin_pairs = ["spin0xspin0", "spin0xspin2", "spin2xspin0", "spin2xspin2"]
n_sims = iStop - iStart
scenarios = ["standard", "noE", "noB"]

spec_list = pspipe_list.get_spec_name_list(d, char="_")

_, sv_list, ar_list = pspipe_list.get_arrays_list(d)
array_list = [f"{sv}_{ar}" for (sv, ar) in zip(sv_list, ar_list)]
lth, cmb_and_fg_dict = best_fits.fg_dict_from_files(bestfit_dir + "/fg_{}x{}.dat",
                                                    array_list,
                                                    lmax + 2,
                                                    spectra,
                                                    f_name_cmb=bestfit_dir + "/cmb.dat")


ps_list = {}
for sid, spec in enumerate(spec_list):
    ps_list[spec] = {}
    for scenario in scenarios:
        for iii in range(iStart, iStop):

            if iii == 0:
                ps_list[spec]["nofilter", scenario] = []
                ps_list[spec]["filter", scenario] = []

            lb, ps_nofilt = so_spectra.read_ps(spec_dir + f"/{type}_{spec}_nofilter_{scenario}_%05d.dat" % iii, spectra=spectra)
            lb, ps_filt = so_spectra.read_ps(spec_dir + f"/{type}_{spec}_filter_{scenario}_%05d.dat" % iii, spectra=spectra)

            ps_list[spec]["nofilter", scenario] += [ps_nofilt]
            ps_list[spec]["filter", scenario] += [ps_filt]


elements  = ["TT_to_TT", "EE_to_EE", "BB_to_BB", "EE_to_BB", "BB_to_EE"]
kspace_matrix = {}

plt.figure(figsize=(12,8))
for spec in spec_list:
    kspace_dict, std, kspace_matrix[spec] = kspace.build_kspace_filter_matrix(lb,
                                                                              ps_list[spec],
                                                                              n_sims,
                                                                              spectra,
                                                                              return_dict=True)

    np.save(f"{tf_dir}/kspace_matrix_{spec}.npy", kspace_matrix[spec])
    for count, el in enumerate(elements):
        plt.subplot(3, 2, count+1)
        plt.ylabel(el)
        plt.xlabel(r"$\ell$")
        plt.errorbar(lb, kspace_dict[el], std[el] / np.sqrt(n_sims), label = spec)
plt.legend()
plt.savefig(f"{plot_dir}/kspace_mat.png", bbox_inches="tight")
plt.clf()
plt.close()

# lets also make sure that the spectrum without filter is unbiased


for spec in spec_list:

    prefix= f"{mcm_dir}/{spec}"

    mbb_inv, Bbl = so_mcm.read_coupling(prefix=prefix,spin_pairs=spin_pairs)

    n1, n2 = spec.split("x")
    bin_theory = so_mcm.apply_Bbl(Bbl, cmb_and_fg_dict[n1, n2], spectra=spectra)



    for iii in range(iStart, iStop):
        lb, ps_list[spec]["filter", "standard"][iii] = kspace.deconvolve_kspace_filter_matrix(lb,
                                                                                              ps_list[spec]["filter", "standard"][iii],
                                                                                              kspace_matrix[spec],
                                                                                              spectra)


    for spectrum in spectra:
        mean, std = {}, {}
        for filt in ["filter", "nofilter"]:

            my_list = []
            for iii in range(iStart, iStop):
                my_list += [ps_list[spec][filt, "standard"][iii][spectrum]]

            mean[filt] = np.mean(my_list, axis=0)
            std[filt] = np.std(my_list, axis=0)

        if spectrum == "TT":
            plt.semilogy()

        plt.plot(lth, cmb_and_fg_dict[n1, n2][spectrum], color="grey", alpha=0.4)
        plt.plot(lb, bin_theory[spectrum])
        plt.errorbar(lb, mean["nofilter"], std["nofilter"], fmt=".", color="red", label = "no filter")
        plt.errorbar(lb, mean["filter"], std["filter"], fmt=".", color="blue", label = "filter corrected")

        plt.title(r"$D_{\ell}$", fontsize=20)
        plt.xlabel(r"$\ell$", fontsize=20)
        plt.legend()
        plt.savefig(f"{plot_dir}/{spec}_{spectrum}.png", bbox_inches="tight")
        plt.clf()
        plt.close()

        plt.errorbar(lb-10, mean["nofilter"] - bin_theory[spectrum], std["nofilter"]  / np.sqrt(n_sims), fmt=".", color="red", label = "no filter")
        plt.errorbar(lb+10, mean["filter"] - bin_theory[spectrum], std["filter"]  / np.sqrt(n_sims), fmt=".", color="blue", label = "filter corrected")
        plt.title(r"$\Delta D_{\ell}$" , fontsize=20)
        plt.xlabel(r"$\ell$", fontsize=20)
        plt.legend()
        plt.savefig(f"{plot_dir}/diff_{spec}_{spectrum}.png", bbox_inches="tight")
        plt.clf()
        plt.close()
